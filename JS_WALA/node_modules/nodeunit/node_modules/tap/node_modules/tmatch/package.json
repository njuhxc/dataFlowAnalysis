{
  "name": "tmatch",
  "version": "4.0.0",
  "description": "This module exists to facilitate the `t.match()` method in [`tap`](http://npm.im/tap).",
  "main": "index.js",
  "scripts": {
    "test": "tap --100 test/*.js -J",
    "preversion": "npm test",
    "postversion": "npm publish",
    "postpublish": "git push origin --all; git push origin --tags"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/isaacs/tmatch.git"
  },
  "author": {
    "name": "Isaac Z. Schlueter",
    "email": "i@izs.me",
    "url": "http://blog.izs.me/"
  },
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/isaacs/tmatch/issues"
  },
  "homepage": "https://github.com/isaacs/tmatch#readme",
  "devDependencies": {
    "tap": "^11.1.5"
  },
  "files": [
    "index.js"
  ],
  "readme": "# tmatch\n\nThis module exists to facilitate the `t.match()` method in\n[`tap`](http://npm.im/tap).\n\nIt checks whether a value matches a given \"pattern\".  A pattern is an\nobject with a set of fields that must be in the test object, or a\nregular expression that a test string must match, or any combination\nthereof.\n\nThe algorithm is borrowed heavily from\n[`only-shallow`](http://npm.im/only-shallow), with some notable\ndifferences with respect to the handling of missing properties and the\nway that regular expressions are compared to strings.\n\n## usage\n\n```javascript\nvar matches = require('tmatch')\n\nif (!matches(testObject, pattern)) console.log(\"yay! diversity!\");\n\n// somewhat more realistic example..\nhttp.get(someUrl).on('response', function (res) {\n  var expect = {\n    statusCode: 200,\n    headers: {\n      server: /express/\n    }\n  }\n\n  if (!tmatch(res, expect)) {\n    throw new Error('Expect 200 status code from express server')\n  }\n})\n```\n\n## details\n\nCopied from the source, here are the details of `tmatch`'s algorithm:\n\n1. If the object loosely equals the pattern, and either they're both\n   objects or neither objects, then return true.  Note that this\n   covers object identity, some type coercion, and matching `null`\n   against `undefined`, and avoids some stuff like `1 == [1]`.\n2. If the object is a RegExp and the pattern is also a RegExp, return\n   true if their source, global, multiline, lastIndex, and ignoreCase\n   fields all match.\n3. If the pattern is a RegExp, then return true if\n   `pattern.test(object)`, casting the object to a string if it is not\n   already a string.\n4. If the pattern is a `Set`, then return true if all the keys in\n   `pattern` appear in `object`.\n5. If the pattern is a `Map`, then return true if all the keys in\n   `pattern` are in `object`, and the values match as well.\n6. If the object is a string and the pattern is a non-empty string,\n   then return true if the string occurs within the object.\n7. If the object and the pattern are both Date objects, then return\n   true if they represent the same date.\n8. If the object is a Date object, and the pattern is a string, then\n   return true if the pattern is parseable as a date that is the same\n   date as the object.\n9. If the object is an `arguments` object, or the pattern is an\n   `arguments` object, then cast them to arrays and compare their\n   contents.\n10. If the pattern is the `Buffer` constructor, then return true if\n    the object is a Buffer.\n11. If the pattern is the `Function` constructor, then return true if\n    the object is a function.\n12. If the pattern is the String constructor, then return true if the\n    pattern is a string.\n13. If the pattern is the Boolean constructor, then return true if the\n    pattern is a boolean.\n14. If the pattern is the Array constructor, then return true if the\n    pattern is an array.\n15. If the pattern is any function, and then object is an object, then\n    return true if the object is an `instanceof` the pattern.\n16. At this point, if the object or the pattern are not objects, then\n    return false (because they would have matched earlier).\n17. If the object is a buffer, and the pattern is also a buffer, then\n    return true if they contain the same bytes.\n18. At this point, both object and pattern are object type values, so\n    compare their keys:\n    1. Get list of all iterable keys in pattern and object.  If both\n       are zero (two empty objects), return true.\n    2. Check to see if this pattern and this object have been tested\n       already (to handle cycles).  If so, return true, since the\n       check higher up in the stack will catch any mismatch.\n    3. For each key in the pattern, match it against the corresponding\n       key in object.  Missing keys in object will be resolved to\n       `undefined`, so it's possible to use `{foo:null}` as a pattern\n       to ensure that the object *doesn't* have a `foo` property.\n\n## license\n\nISC. Go nuts.\n",
  "readmeFilename": "README.md",
  "_id": "tmatch@4.0.0",
  "dist": {
    "shasum": "838020d7143d05e98fb2740c0e71428ba6d03c8d"
  },
  "_from": "tmatch@^4.0.0",
  "_resolved": "https://registry.npmjs.org/tmatch/-/tmatch-4.0.0.tgz"
}
