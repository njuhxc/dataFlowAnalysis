{
  "name": "webidl2",
  "description": "A WebIDL Parser",
  "version": "17.0.1",
  "contributors": [
    {
      "name": "Robin Berjon",
      "email": "robin@berjon.com",
      "url": "https://berjon.com"
    },
    {
      "name": "Marcos Caceres",
      "email": "marcos@marcosc.com",
      "url": "https://marcosc.com"
    },
    {
      "name": "Kagami Sascha Rosylight",
      "email": "saschaplas@outlook.com"
    },
    {
      "name": "Timothy Gu",
      "email": "timothygu99@gmail.com"
    }
  ],
  "license": "W3C",
  "dependencies": {},
  "devDependencies": {
    "eslint": "^5.9.0",
    "expect": "23.6.0",
    "jsondiffpatch": "0.3.11",
    "mocha": "5.2.0"
  },
  "scripts": {
    "lint": "eslint lib/*.js test/*.js test/util/*.js",
    "test": "npm run lint && mocha",
    "acquire": "node test/util/acquire.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/w3c/webidl2.js"
  },
  "main": "index.js",
  "files": [
    "lib/*"
  ],
  "readme": "\r\n# WebIDL 2\r\n\r\n[![NPM version](https://badge.fury.io/js/webidl2.svg)](http://badge.fury.io/js/webidl2)\r\n\r\n## Purpose\r\n\r\nThis is a parser for the [WebIDL](http://dev.w3.org/2006/webapi/WebIDL/) language. If\r\nyou don't know what that is, then you probably don't need it. It is meant to be used\r\nboth in Node and in the browser (the parser likely works in other JS environments, but\r\nnot the test suite).\r\n\r\n## Installation\r\n\r\nJust the usual. For Node:\r\n\r\n```Bash\r\nnpm install webidl2\r\n```\r\n\r\nIn the browser:\r\n\r\n```HTML\r\n<script src='webidl2.js'></script>\r\n```\r\n\r\n## Documentation\r\n\r\nWebIDL2 provides two functions: `parse` and `write`.\r\n\r\n* `parse`: Converts a WebIDL string into a syntax tree.\r\n* `write`: Converts a syntax tree into a WebIDL string. Useful for programmatic code\r\n  modification.\r\n\r\nIn Node, that happens with:\r\n\r\n```JS\r\nvar WebIDL2 = require(\"webidl2\");\r\nvar tree = WebIDL2.parse(\"string of WebIDL\");\r\nvar text = WebIDL2.write(tree);\r\n```\r\n\r\nIn the browser:\r\n```HTML\r\n<script src='webidl2.js'></script>\r\n<script>\r\n  var tree = WebIDL2.parse(\"string of WebIDL\");\r\n</script>\r\n\r\n<script src='writer.js'></script>\r\n<script>\r\n  var text = WebIDL2Writer.write(tree);\r\n</script>\r\n```\r\n\r\n`write()` optionally takes a \"templates\" object, whose properties are functions that process input in different ways (depending on what is needed for output). Every property is optional. Each property is documented below:\r\n\r\n```js\r\nvar result = WebIDL2.write(tree, {\r\n  templates: {\r\n    /**\r\n     * A function that receives syntax strings plus anything the templates returned.\r\n     * The items are guaranteed to be ordered.\r\n     * The returned value may be again passed to any template functions,\r\n     * or it may also be the final return value of `write()`.\r\n     * @param {any[]} items\r\n     */\r\n    wrap: items => items.join(\"\"),\r\n    /**\r\n     * @param {string} t A trivia string, which includes whitespaces and comments.\r\n     */\r\n    trivia: t => t,\r\n    /**\r\n     * The identifier for a container type. For example, the `Foo` part of `interface Foo {};`.\r\n     * @param {string} escaped The escaped raw name of the definition.\r\n     * @param data The definition with the name\r\n     * @param parent The parent of the definition, undefined if absent\r\n     */\r\n    name: (escaped, { data, parent }) => escaped,\r\n    /**\r\n     * Called for each type referece, e.g. `Window`, `Promise`, or `unsigned long`.\r\n     * @param escaped The referenced name. Typically string, but may also be the return\r\n     *            value of `wrap()` if the name contains whitespace.\r\n     * @param unescaped Unescaped reference.\r\n     */\r\n    reference: (escaped, unescaped) => escaped,\r\n    /**\r\n     * Called only once for each types, e.g. `Document`, `Promise<DOMString>`, or `sequence<long>`.\r\n     * @param type The `wrap()`ed result of references and syntatic bracket strings.\r\n     */\r\n    type: type => type,\r\n    /**\r\n     * Called for each value literals, e.g. `\"string\"` or `3.12`.\r\n     * @param {string} lit The raw literal string.\r\n     */\r\n    valueLiteral: lit => lit,\r\n    /**\r\n     * Receives the return value of `reference()`. String if it's absent.\r\n     */\r\n    inheritance: inh => inh,\r\n    /**\r\n     * Called for each IDL type definition, e.g. an interface, an operation, or a typedef.\r\n     * @param content The wrapped value of everything the definition contains.\r\n     * @param data The original definition object\r\n     * @param parent The parent of the definition, undefined if absent\r\n     */\r\n    definition: (content, { data, parent }) => content,\r\n    /**\r\n     * Called for each extended attribute annotation.\r\n     * @param content The wrapped value of everything the annotation contains.\r\n     */\r\n    extendedAttribute: content => contents.join(\"\"),\r\n    /**\r\n     * The `Foo` part of `[Foo=Whatever]`.\r\n     * @param ref The name of the referenced extended attribute name.\r\n     */\r\n    extendedAttributeReference: ref => ref\r\n  }\r\n});\r\n```\r\n\r\n\"Wrapped value\" here will all be raw strings when the `wrap()` callback is absent.\r\n\r\n### Errors\r\n\r\nWhen there is a syntax error in the WebIDL, it throws an exception object with the following\r\nproperties:\r\n\r\n* `message`: the error message\r\n* `line`: the line at which the error occurred.\r\n* `input`: a short peek at the text at the point where the error happened\r\n* `tokens`: the five tokens at the point of error, as understood by the tokeniser\r\n  (this is the same content as `input`, but seen from the tokeniser's point of view)\r\n\r\nThe exception also has a `toString()` method that hopefully should produce a decent\r\nerror message.\r\n\r\n### AST (Abstract Syntax Tree)\r\n\r\nThe `parse()` method returns a tree object representing the parse tree of the IDL.\r\nComment and white space are not represented in the AST.\r\n\r\nThe root of this object is always an array of definitions (where definitions are\r\nany of interfaces, dictionaries, callbacks, etc. â€” anything that can occur at the root\r\nof the IDL).\r\n\r\n### IDL Type\r\n\r\nThis structure is used in many other places (operation return types, argument types, etc.).\r\nIt captures a WebIDL type with a number of options. Types look like this and are typically\r\nattached to a field called `idlType`:\r\n\r\n```JS\r\n{\r\n  \"type\": \"attribute-type\",\r\n  \"generic\": null,\r\n  \"idlType\": \"unsigned short\",\r\n  \"nullable\": null,\r\n  \"union\": false,\r\n  \"baseName\": \"short\",\r\n  \"prefix\": {\r\n    \"value\": \"unsigned\",\r\n    \"trivia\": \" \"\r\n  },\r\n  \"postfix\": null,\r\n  \"separator\": null,\r\n  \"trivia\": {\r\n    \"base\": \" \"\r\n  },\r\n  \"extAttrs\": {\r\n    \"trivia\": {\r\n      \"open\": \"\\n\",\r\n      \"close\": \"\"\r\n    },\r\n    \"items\": [...]\r\n  }\r\n}\r\n```\r\n\r\nWhere the fields are as follows:\r\n\r\n* `type`: String indicating where this type is used. Can be `null` if not applicable.\r\n* `generic`: An object with the following fields if the type is generic:\r\n  * `value`: String indicating the generic type (e.g. \"Promise\", \"sequence\").\r\n  * `trivia`: Whitespaces or comments preceding genenic type name token.\r\n* `idlType`: String indicating the type name, or array of subtypes if the type is\r\n  generic or a union.\r\n* `baseName`: String indicating the base type name, e.g. \"float\" for \"unrestricted\r\n  float\".\r\n* `prefix`: An object with the following fields if a prefix exists:\r\n  * `value`: String indicating the prefix name (\"unsigned\" or \"unrestricted\").\r\n  * `trivia`: Whitespaces or comments preceding prefix token.\r\n* `postfix`: An object with the following fields if a postfix exists:\r\n  * `value`: String indicating the prefix name, currently only for \"unsigned long long\".\r\n  * `trivia`: Whitespaces or comments preceding postfix token.\r\n* `separator`: An object with the following fields if a separator follows:\r\n  * `value`: String indicating the separator token value, e.g. \",\" or \"or\".\r\n  * `trivia`: Whitespaces or comments preceding separator token.\r\n* `nullable`: An object with a string type field `trivia` if the type is nullable.\r\n* `union`: Boolean indicating whether this is a union type or not.\r\n* `extAttrs`: An [extended attributes](#extended-attributes) container.\r\n\r\n### Trivia\r\n\r\nStructures often have `trivia` field that represents whitespaces and comments before tokens. It gives a string if the syntatic component is made of a single token or an object with multiple string type fields.\r\n\r\nA trivia object looks like the following example:\r\n\r\n```JS\r\n{\r\n  \"base\": \"\\n\",\r\n  \"name\": \" \",\r\n  \"...\": \"...\"\r\n}\r\n```\r\n\r\nFrequently, `base` is for type keywords, `name` is for identifiers, `open`/`close` are for brackets, and `termination` for semicolons.\r\n\r\n### Interface\r\n\r\nInterfaces look like this:\r\n\r\n```JS\r\n{\r\n  \"type\": \"interface\",\r\n  \"name\": \"Animal\",\r\n  \"partial\": null,\r\n  \"members\": [...],\r\n  \"trivia\": {\r\n    \"base\": \"\",\r\n    \"name\": \" \",\r\n    \"open\": \" \",\r\n    \"close\": \"\\n\",\r\n    \"termination\": \"\"\r\n  },\r\n  \"inheritance\": null,\r\n  \"extAttrs\": [...]\r\n}, {\r\n  \"type\": \"interface\",\r\n  \"name\": \"Human\",\r\n  \"partial\": null,\r\n  \"members\": [...],\r\n  \"trivia\": {\r\n    \"base\": \"\\n\\n\",\r\n    \"name\": \" \",\r\n    \"open\": \" \",\r\n    \"close\": \"\\n\",\r\n    \"termination\": \"\"\r\n  },\r\n  \"inheritance\": {\r\n    \"name\": \"Animal\",\r\n    \"trivia\": {\r\n      \"colon\": \" \",\r\n      \"name\": \" \"\r\n    }\r\n  },\r\n  \"extAttrs\": {\r\n    \"trivia\": {\r\n      \"open\": \"\\n\\n\",\r\n      \"close\": \"\"\r\n    },\r\n    \"items\": [...]\r\n  }\r\n}\r\n```\r\n\r\nThe fields are as follows:\r\n\r\n* `type`: Always \"interface\".\r\n* `name`: The name of the interface.\r\n* `partial`: If a partial interface, an object with a string type field `trivia`. Otherwise, `null`.\r\n* `members`: An array of interface members (attributes, operations, etc.). Empty if there are none.\r\n* `trivia`: A trivia object.\r\n* `inheritance`: An object giving the name of an interface this one inherits from, `null` otherwise.\r\n* `extAttrs`: An [extended attributes](#extended-attributes) container.\r\n\r\n### Interface mixins\r\n\r\nInterfaces mixins look like this:\r\n\r\n```JS\r\n{\r\n  \"type\": \"interface mixin\",\r\n  \"name\": \"Animal\",\r\n  \"partial\": null,\r\n  \"members\": [...],\r\n  \"trivia\": {\r\n    \"base\": \"\",\r\n    \"mixin\": \" \",\r\n    \"name\": \" \",\r\n    \"open\": \" \",\r\n    \"close\": \"\\n\",\r\n    \"termination\": \"\"\r\n  },\r\n  \"extAttrs\": [...]\r\n}, {\r\n  \"type\": \"interface mixin\",\r\n  \"name\": \"Human\",\r\n  \"partial\": null,\r\n  \"members\": [...],\r\n  \"trivia\": {\r\n    \"base\": \"\",\r\n    \"mixin\": \" \",\r\n    \"name\": \" \",\r\n    \"open\": \" \",\r\n    \"close\": \"\\n\",\r\n    \"termination\": \"\"\r\n  },\r\n  \"extAttrs\": {\r\n    \"trivia\": {\r\n      \"open\": \"\\n\\n\",\r\n      \"close\": \"\"\r\n    },\r\n    \"items\": [...]\r\n  }\r\n}\r\n```\r\n\r\nThe fields are as follows:\r\n\r\n* `type`: Always \"interface mixin\".\r\n* `name`: The name of the interface mixin.\r\n* `partial`: If a partial interface mixin, an object with a string type field `trivia`. Otherwise, `null`.\r\n* `members`: An array of interface members (attributes, operations, etc.). Empty if there are none.\r\n* `trivia`: A trivia object.\r\n* `extAttrs`: An [extended attributes](#extended-attributes) container.\r\n\r\n### Namespace\r\n\r\nNamespaces look like this:\r\n\r\n```JS\r\n{\r\n  \"type\": \"namespace\",\r\n  \"name\": \"Console\",\r\n  \"partial\": null,\r\n  \"members\": [...],\r\n  \"trivia\": {\r\n    \"base\": \"\",\r\n    \"name\": \" \",\r\n    \"open\": \" \",\r\n    \"close\": \"\\n\",\r\n    \"termination\": \"\"\r\n  },\r\n  \"extAttrs\": {\r\n    \"trivia\": {\r\n      \"open\": \"\\n\\n\",\r\n      \"close\": \"\"\r\n    },\r\n    \"items\": [...]\r\n  }\r\n}\r\n```\r\n\r\nThe fields are as follows:\r\n\r\n* `type`: Always \"namespace\".\r\n* `name`: The name of the namespace.\r\n* `partial`: If a partial namespace, an object with a string type field `trivia`. Otherwise, `null`.\r\n* `members`: An array of namespace members (attributes and operations). Empty if there are none.\r\n* `trivia`: A trivia object.\r\n* `extAttrs`: An [extended attributes](#extended-attributes) container.\r\n\r\n### Callback Interfaces\r\n\r\nThese are captured by the same structure as [Interfaces](#interface) except that\r\ntheir `type` field is \"callback interface\". Its trivia object additionally\r\nincludes a new field `callback`.\r\n\r\n### Callback\r\n\r\nA callback looks like this:\r\n\r\n```JS\r\n{\r\n  \"type\": \"callback\",\r\n  \"name\": \"AsyncOperationCallback\",\r\n  \"idlType\": {\r\n    \"type\": \"return-type\",\r\n    \"generic\": null,\r\n    \"nullable\": null,\r\n    \"union\": false,\r\n    \"idlType\": \"void\",\r\n    \"baseName\": \"void\",\r\n    \"prefix\": null,\r\n    \"postfix\": null,\r\n    \"separator\": null,\r\n    \"extAttrs\": null,\r\n    \"trivia\": {\r\n      \"base\": \" \"\r\n    }\r\n  },\r\n  \"arguments\": [...],\r\n  \"trivia\": {\r\n    \"base\": \"\",\r\n    \"name\": \" \",\r\n    \"assign\": \" \",\r\n    \"open\": \" \",\r\n    \"close\": \"\",\r\n    \"termination\": \"\"\r\n  },\r\n  \"extAttrs\": null\r\n}\r\n```\r\n\r\nThe fields are as follows:\r\n\r\n* `type`: Always \"callback\".\r\n* `name`: The name of the callback.\r\n* `idlType`: An [IDL Type](#idl-type) describing what the callback returns.\r\n* `arguments`: A list of [arguments](#arguments), as in function paramters.\r\n* `trivia`: A trivia object. The field `assign` is for the equal sign token.\r\n* `extAttrs`: An [extended attributes](#extended-attributes) container.\r\n\r\n### Dictionary\r\n\r\nA dictionary looks like this:\r\n\r\n```JS\r\n{\r\n  \"type\": \"dictionary\",\r\n  \"name\": \"PaintOptions\",\r\n  \"partial\": null,\r\n  \"members\": [{\r\n    \"type\": \"field\",\r\n    \"name\": \"fillPattern\",\r\n    \"escapedName\": \"fillPattern\",\r\n    \"required\": null,\r\n    \"idlType\": {\r\n      \"type\": \"dictionary-type\",\r\n      \"generic\": null,\r\n      \"nullable\": {\r\n        \"trivia\": \"\"\r\n      },\r\n      \"union\": false,\r\n      \"idlType\": \"DOMString\",\r\n      \"baseName\": \"DOMString\",\r\n      \"prefix\": null,\r\n      \"postfix\": null,\r\n      \"separator\": null,\r\n      \"extAttrs\": [...],\r\n      \"trivia\": {\r\n        \"base\": \"\\n  \"\r\n      }\r\n    },\r\n    \"extAttrs\": null,\r\n    \"default\": {\r\n      \"type\": \"string\",\r\n      \"value\": \"black\",\r\n      \"trivia\": {\r\n        \"assign\": \" \",\r\n        \"value\": \" \"\r\n      }\r\n    }\r\n  }],\r\n  \"trivia\": {\r\n    \"base\": \"// Extracted from Web IDL editors draft May 31 2011\\n\",\r\n    \"name\": \" \",\r\n    \"open\": \" \",\r\n    \"close\": \"\\n\",\r\n    \"termination\": \"\"\r\n  },\r\n  \"inheritance\": null,\r\n  \"extAttrs\": null\r\n}\r\n```\r\n\r\nThe fields are as follows:\r\n\r\n* `type`: Always \"dictionary\".\r\n* `name`: The dictionary name.\r\n* `escapedName`: The dictionary name including possible escaping underscore.\r\n* `partial`: If the type is a partial dictionary, an object with a string type field `trivia`. Otherwise, `null`.\r\n* `members`: An array of members (see below).\r\n* `trivia`: A trivia object.\r\n* `inheritance`: An object indicating which dictionary is being inherited from, `null` otherwise.\r\n* `extAttrs`: An [extended attributes](#extended-attributes) container.\r\n\r\nAll the members are fields as follows:\r\n\r\n* `type`: Always \"field\".\r\n* `name`: The name of the field.\r\n* `required`: If the field is required, an object with a string type field `trivia`. Otherwise, `null`.\r\n* `idlType`: An [IDL Type](#idl-type) describing what field's type.\r\n* `extAttrs`: An [extended attributes](#extended-attributes) container.\r\n* `default`: A [default value](#default-and-const-values), absent if there is none.\r\n\r\n### Enum\r\n\r\nAn enum looks like this:\r\n\r\n```JS\r\n{\r\n  \"type\": \"enum\",\r\n  \"name\": \"MealType\",\r\n  \"values\": [\r\n    {\r\n      \"type\": \"enum-value\",\r\n      \"value\": \"rice\",\r\n      \"trivia\": \" \",\r\n      \"separator\": {\r\n        \"value\": \",\",\r\n        \"trivia\": \"\"\r\n      }\r\n    },\r\n    {\r\n      \"type\": \"enum-value\",\r\n      \"value\": \"noodles\",\r\n      \"trivia\": \" \",\r\n      \"separator\": {\r\n        \"value\": \",\",\r\n        \"trivia\": \"\"\r\n      }\r\n    },\r\n    {\r\n      \"type\": \"enum-value\",\r\n      \"value\": \"other\",\r\n      \"trivia\": \" \",\r\n      \"separator\": null\r\n    }\r\n  ],\r\n  \"trivia\": {\r\n    \"base\": \"\",\r\n    \"name\": \" \",\r\n    \"open\": \" \",\r\n    \"close\": \" \",\r\n    \"termination\": \"\"\r\n  },\r\n  \"extAttrs\": null\r\n}\r\n```\r\n\r\nThe fields are as follows:\r\n\r\n* `type`: Always \"enum\".\r\n* `name`: The enum's name.\r\n* `values`: An array of values, which may include a field `separator` for proceding commas. The type of value is \"enum-value\".\r\n* `trivia`: A trivia object.\r\n* `extAttrs`: An [extended attributes](#extended-attributes) container.\r\n\r\n### Typedef\r\n\r\nA typedef looks like this:\r\n\r\n```JS\r\n{\r\n  \"type\": \"typedef\",\r\n  \"idlType\": {\r\n    \"type\": \"typedef-type\",\r\n    \"generic\": \"sequence\",\r\n    \"nullable\": false,\r\n    \"union\": false,\r\n    \"idlType\": [\r\n      {\r\n        \"type\": \"typedef-type\",\r\n        \"generic\": null,\r\n        \"nullable\": null,\r\n        \"union\": false,\r\n        \"idlType\": \"Point\",\r\n        \"baseName\": \"Point\",\r\n        \"prefix\": null,\r\n        \"postfix\": null,\r\n        \"separator\": null,\r\n        \"extAttrs\": [...]\r\n        \"trivia\": {\r\n            \"base\": \"\"\r\n        }\r\n      }\r\n    ],\r\n    \"extAttrs\": [...]\r\n  },\r\n  \"name\": \"PointSequence\",\r\n  \"trivia\": {\r\n    \"base\": \"\\n\\n      \",\r\n    \"name\": \" \",\r\n    \"termination\": \"\"\r\n  },\r\n  \"extAttrs\": null\r\n}\r\n```\r\n\r\n\r\nThe fields are as follows:\r\n\r\n* `type`: Always \"typedef\".\r\n* `name`: The typedef's name.\r\n* `idlType`: An [IDL Type](#idl-type) describing what typedef's type.\r\n* `trivia`: A trivia object.\r\n* `extAttrs`: An [extended attributes](#extended-attributes) container.\r\n\r\n### Includes\r\n\r\nAn includes definition looks like this:\r\n\r\n```JS\r\n{\r\n  \"type\": \"includes\",\r\n  \"target\": \"Node\",\r\n  \"includes\": \"EventTarget\",\r\n  \"extAttrs\": null\r\n}\r\n```\r\n\r\nThe fields are as follows:\r\n\r\n* `type`: Always \"includes\".\r\n* `target`: The interface that includes an interface mixin.\r\n* `includes`: The interface mixin that is being included by the target.\r\n* `trivia`: A trivia object. The field `target` is for the base interface identifier, `includes` for the `includes` keyword, and `mixin` for the mixin identifier.\r\n* `extAttrs`: An [extended attributes](#extended-attributes) container.\r\n\r\n### Operation Member\r\n\r\nAn operation looks like this:\r\n```JS\r\n{\r\n  \"type\": \"operation\",\r\n  \"getter\": null,\r\n  \"setter\": null,\r\n  \"deleter\": null,\r\n  \"static\": null,\r\n  \"stringifier\": null,\r\n  \"body\": {\r\n    \"idlType\": {\r\n      \"type\": \"return-type\",\r\n      \"generic\": null,\r\n      \"nullable\": null,\r\n      \"union\": false,\r\n      \"idlType\": \"void\",\r\n      \"baseName\": \"void\",\r\n      \"prefix\": null,\r\n      \"postfix\": null,\r\n      \"separator\": null,\r\n      \"extAttrs\": null,\r\n      \"trivia\": {\r\n        \"base\": \"\\n  \"\r\n      }\r\n    },\r\n    \"trivia\": {\r\n      \"open\": \"\",\r\n      \"close\": \"\"\r\n    },\r\n    \"name\": {\r\n      \"value\": \"intersection\",\r\n      \"escaped\": \"intersection\",\r\n      \"trivia\": \" \"\r\n    },\r\n    \"arguments\": [{\r\n      \"optional\": false,\r\n      \"variadic\": true,\r\n      \"extAttrs\": null,\r\n      \"idlType\": {\r\n        \"type\": \"argument-type\",\r\n        \"generic\": null,\r\n        \"nullable\": false,\r\n        \"union\": false,\r\n        \"idlType\": \"long\",\r\n        \"extAttrs\": [...]\r\n      },\r\n      \"name\": \"ints\"\r\n    }],\r\n  },\r\n  \"trivia\": {\r\n    \"termination\": \"\"\r\n  },\r\n  \"extAttrs\": null\r\n}\r\n```\r\n\r\nThe fields are as follows:\r\n\r\n* `type`: Always \"operation\".\r\n* `getter`: If a getter operation, an object with a string type field `trivia`. Otherwise, `null`.\r\n* `setter`: If a setter operation, an object with a string type field `trivia`. Otherwise, `null`.\r\n* `deleter`: If a deleter operation, an object with a string type field `trivia`. Otherwise, `null`.\r\n* `static`: If a static operation, an object with a string type field `trivia`. Otherwise, `null`.\r\n* `stringifier`: If a stringifier operation, an object with a string type field `trivia`. Otherwise, `null`.\r\n* `trivia`: A trivia object.\r\n* `body`: The operation body. Can be null if bodyless `stringifier`.\r\n* `extAttrs`: An [extended attributes](#extended-attributes) container.\r\n\r\nThe operation body fields are as follows:\r\n\r\n* `idlType`: An [IDL Type](#idl-type) of what the operation returns.\r\n* `trivia`: A trivia object.\r\n* `name`: The name of the operation if exists.\r\n* `arguments`: An array of [arguments](#arguments) for the operation.\r\n\r\n### Attribute Member\r\n\r\nAn attribute member looks like this:\r\n\r\n```JS\r\n{\r\n  \"type\": \"attribute\",\r\n  \"static\": null,\r\n  \"stringifier\": null,\r\n  \"inherit\": null,\r\n  \"readonly\": null,\r\n  \"trivia\": {\r\n    \"base\": \"\",\r\n    \"name\": \" \",\r\n    \"termination\": \"\"\r\n  },\r\n  \"idlType\": {\r\n    \"type\": \"attribute-type\",\r\n    \"generic\": null,\r\n    \"nullable\": null,\r\n    \"union\": false,\r\n    \"idlType\": \"any\",\r\n    \"baseName\": \"any\",\r\n    \"prefix\": null,\r\n    \"postfix\": null,\r\n    \"separator\": null,\r\n    \"extAttrs\": [...],\r\n    \"trivia\": {\r\n      \"base\": \" \"\r\n    }\r\n  },\r\n  \"name\": \"regexp\",\r\n  \"escapedName\": \"regexp\",\r\n  \"extAttrs\": null\r\n}\r\n```\r\n\r\nThe fields are as follows:\r\n\r\n* `type`: Always \"attribute\".\r\n* `name`: The attribute's name.\r\n* `escapedName`: The attribute's name including possible escaping underscore.\r\n* `static`: If it's a static attribute, an object with a string type field `trivia`. Otherwise, `null`.\r\n* `stringifier`: If it's a stringifier attribute, an object with a string type field `trivia`. Otherwise, `null`.\r\n* `inherit`: If it's an inherit attribute, an object with a string type field `trivia`. Otherwise, `null`.\r\n* `readonly`: If it's a read-only attribute, an object with a string type field `trivia`. Otherwise, `null`.\r\n* `trivia`: A trivia object.\r\n* `idlType`: An [IDL Type](#idl-type) for the attribute.\r\n* `extAttrs`: An [extended attributes](#extended-attributes) container.\r\n\r\n### Constant Member\r\n\r\nA constant member looks like this:\r\n\r\n```JS\r\n{\r\n  \"type\": \"const\",\r\n  \"idlType\": {\r\n    \"type\": \"const-type\",\r\n    \"generic\": null,\r\n    \"nullable\": null,\r\n    \"union\": false,\r\n    \"idlType\": \"boolean\",\r\n    \"baseName\": \"boolean\",\r\n    \"prefix\": null,\r\n    \"postfix\": null,\r\n    \"separator\": null,\r\n    \"extAttrs\": null,\r\n    \"trivia\": {\r\n      \"base\": \" \"\r\n    }\r\n  },\r\n  \"name\": \"DEBUG\",\r\n  \"value\": {\r\n    \"type\": \"boolean\",\r\n    \"value\": false\r\n  },\r\n  \"trivia\": {\r\n    \"base\": \"\\n  \",\r\n    \"name\": \" \",\r\n    \"assign\": \" \",\r\n    \"value\": \" \",\r\n    \"termination\": \"\"\r\n  },\r\n  \"extAttrs\": null\r\n}\r\n```\r\n\r\nThe fields are as follows:\r\n\r\n* `type`: Always \"const\".\r\n* `idlType`: An [IDL Type](#idl-type) of the constant that represents a simple type, the type name.\r\n* `name`: The name of the constant.\r\n* `value`: The constant value as described by [Const Values](#default-and-const-values)\r\n* `trivia`: A trivia object. The field `assign` is for the equal sign token.\r\n* `extAttrs`: An [extended attributes](#extended-attributes) container.\r\n\r\n### Arguments\r\n\r\nThe arguments (e.g. for an operation) look like this:\r\n\r\n```JS\r\n{\r\n  \"arguments\": [{\r\n    \"optional\": null,\r\n    \"variadic\": {\r\n      \"trivia\": \"\"\r\n    },\r\n    \"extAttrs\": null,\r\n    \"trivia\": {\r\n      \"name\": \" \"\r\n    },\r\n    \"idlType\": {\r\n      \"type\": \"argument-type\",\r\n      \"generic\": null,\r\n      \"nullable\": null,\r\n      \"union\": false,\r\n      \"idlType\": \"float\",\r\n      \"baseName\": \"float\",\r\n      \"prefix\": null,\r\n      \"postfix\": null,\r\n      \"separator\": null,\r\n      \"extAttrs\": [...],\r\n      \"trivia\": {\r\n        \"base\": \" \"\r\n      }\r\n    },\r\n    \"name\": \"ints\",\r\n    \"escapedName\": \"ints\",\r\n    \"separator\": {\r\n      \"value\": \",\",\r\n      \"trivia\": \"\"\r\n    }\r\n  }]\r\n}\r\n```\r\n\r\nThe fields are as follows:\r\n\r\n* `optional`: If the argument is optional, an object with a string type field `trivia`. Otherwise, `null`.\r\n* `variadic`: If the argument is variadic, an object with a string type field `trivia`. Otherwise, `null`.\r\n* `idlType`: An [IDL Type](#idl-type) describing the type of the argument.\r\n* `name`: The argument's name.\r\n* `escapedName`: The argument's name including possible escaping underscore.\r\n* `separator`: An object with the following fields if a separator follows:\r\n  * `value`: Always \",\".\r\n  * `trivia`: Whitespaces or comments preceding separator token.\r\n* `trivia`: A trivia object.\r\n* `extAttrs`: An [extended attributes](#extended-attributes) container.\r\n\r\n### Extended Attributes\r\n\r\nExtended attribute container look like this:\r\n\r\n```JS\r\n{\r\n  \"extAttrs\": {\r\n    \"trivia\": {\r\n      \"open\": \"\\n\\n\",\r\n      \"close\": \"\"\r\n    },\r\n    \"items\": [{\r\n      \"name\": \"TreatNullAs\",\r\n      \"signature\": {\r\n        \"arguments\": [...],\r\n        \"trivia\": {\r\n          \"open\": \"\",\r\n          \"close\": \"\"\r\n        }\r\n      },\r\n      \"type\": \"extended-attribute\",\r\n      \"rhs\": {\r\n        \"type\": \"identifier\",\r\n        \"value\": \"EmptyString\",\r\n        \"trivia\": {\r\n          \"assign\": \"\",\r\n          \"value\": \"\"\r\n        }\r\n      },\r\n      \"trivia\": {\r\n        \"name\": \"\"\r\n      },\r\n      \"separator\": null\r\n    }]\r\n  }\r\n}\r\n```\r\n\r\nThe fields are as follows:\r\n\r\n* `trivia`: A trivia object.\r\n* `items`: An array of extended attributes.\r\n\r\nExtended attributes look like this:\r\n\r\n* `name`: The extended attribute's name.\r\n* `signature`: An object containing trivia and [arguments](#arguments), if the extended\r\n  attribute has a signature (e.g. `[Foo()]`) or if its right-hand side does (e.g.\r\n  `[NamedConstructor=Name(DOMString blah)]`).\r\n* `type`: Always `\"extended-attribute\"`.\r\n* `rhs`: If there is a right-hand side, this will capture its `type` (which can be\r\n  \"identifier\" or \"identifier-list\"), its `value`, and its preceding trivia.\r\n* `trivia`: A trivia object.\r\n* `separator`: An object with the following fields if a separator follows:\r\n  * `value`: Always \",\".\r\n  * `trivia`: Whitespaces or comments preceding separator token.\r\n\r\n### Default and Const Values\r\n\r\nDictionary fields and operation arguments can take default values, and constants take\r\nvalues, all of which have the following fields:\r\n\r\n* `type`: One of string, number, boolean, null, Infinity, NaN, or sequence.\r\n\r\nFor string, number, boolean, and sequence:\r\n\r\n* `value`: The value of the given type, as a string. For sequence, the only possible value is `[]`.\r\n\r\nFor Infinity:\r\n\r\n* `negative`: Boolean indicating whether this is negative Infinity or not.\r\n\r\n### `iterable<>`, `maplike<>`, `setlike<>` declarations\r\n\r\nThese appear as members of interfaces that look like this:\r\n\r\n```JS\r\n{\r\n  \"type\": \"maplike\", // or \"iterable\" / \"setlike\"\r\n  \"idlType\": /* One or two types */ ,\r\n  \"readonly\": null, // only for maplike and setlike\r\n  \"trivia\": {\r\n    \"base\": \" \",\r\n    \"open\": \"\",\r\n    \"close\": \"\",\r\n    \"termination\": \"\"\r\n  },\r\n  \"extAttrs\": null\r\n}\r\n```\r\n\r\nThe fields are as follows:\r\n\r\n* `type`: Always one of \"iterable\", \"maplike\" or \"setlike\".\r\n* `idlType`: An array with one or more [IDL Types](#idl-type) representing the declared type arguments.\r\n* `readonly`: If the maplike or setlike is declared as read only, an object with a string type field `trivia`. Otherwise, `null`.\r\n* `trivia`: A trivia object.\r\n* `extAttrs`: An [extended attributes](#extended-attributes) container.\r\n\r\n## Testing\r\n\r\n### Running\r\n\r\nThe test runs with mocha and expect.js. Normally, running `npm test` in the root directory\r\nshould be enough once you're set up.\r\n\r\n### Browser tests\r\n\r\nIn order to test in the browser, get inside `test/web` and run `make-web-tests.js`. This\r\nwill generate a `browser-tests.html` file that you can open in a browser. As of this\r\nwriting tests pass in the latest Firefox, Chrome, Opera, and Safari. Testing on IE\r\nand older versions will happen progressively.\r\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/w3c/webidl2.js/issues"
  },
  "_id": "webidl2@17.0.1",
  "dist": {
    "shasum": "fe26451b9eafb2a763f97cc2a0f44ce219d2547b"
  },
  "_from": "webidl2@*",
  "_resolved": "https://registry.npmjs.org/webidl2/-/webidl2-17.0.1.tgz"
}
